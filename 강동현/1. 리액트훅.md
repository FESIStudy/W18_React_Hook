# 리액트 훅의 기본 철학과 설계 원칙
## 1. 훅이 왜 도입되었는가?
### ✅ 클래스 컴포넌트의 주요 문제점
1. 로직 재사용이 어렵다
- 클래스 컴포넌트에서는 로직을 재사용하려면 HOC(High Order Component)나 render props를 사용해야 했습니다.
- 이들은 코드 구조를 복잡하게 만들고, 디버깅과 추적이 어려웠습니다.
2. 복잡한 컴포넌트의 로직이 분산됨
- 예: componentDidMount, componentDidUpdate, componentWillUnmount 등 여러 생명주기 메서드에 하나의 기능 관련 코드가 나눠서 작성되어야 했습니다.
- 하나의 기능이 여러 함수에 분산되어 유지보수가 어려움.
3. this 키워드 문제
- 클래스 컴포넌트에서는 this 바인딩 이슈가 자주 발생.
- this.handleClick = this.handleClick.bind(this) 같은 반복적인 코드가 필요.
4. 최적화 어려움
- 메모이제이션, 상태 분리, 효율적 리렌더링 등을 관리하기 어렵고 실수하기 쉬움.

**🔄 훅을 통한 해결**
- 함수형 컴포넌트에서 useState, useEffect, useMemo, useCallback 등의 훅을 통해 위 문제들을 함수 내부에서 깔끔하게 해결 가능.
- 관심사를 기능 단위로 묶을 수 있고, 컴포넌트 로직을 추상화하여 커스텀 훅으로 재사용 가능.

## 2. 훅은 단순한 함수가 아닌, “렌더링 컨텍스트와 연결된 상태 머신”
### ✅ 훅의 핵심 개념
- 훅은 단순히 함수를 호출하면 값이 반환되는 구조가 아닙니다.
- React 내부에서 관리되는 상태 저장소에 연결된 포인터입니다.
- React는 렌더링 시점마다 훅의 순서에 따라 상태 값을 할당하고 추적합니다.
### 🔁 상태 머신처럼 동작하는 이유
- React는 컴포넌트가 렌더링될 때마다 훅을 호출하고, 내부적으로 훅이 호출된 순서를 기억합니다.
- 마치 "순차적으로 상태 슬롯을 할당하는 상태 머신"처럼 작동합니다.

예:
```jsx
function Counter() {
  const [count, setCount] = useState(0); // 첫 번째 훅
  const [text, setText] = useState('');  // 두 번째 훅
  ...
}
```
- 이 경우 count와 text는 각각 "슬롯 0", "슬롯 1"에 저장됩니다.
- 다음 렌더에서도 React는 같은 순서로 훅을 실행하여 올바른 상태 값을 찾아냅니다.

## 3. 훅의 호출 규칙: Top-level only, 조건문에서 호출 금지
### ✅ 왜 이런 규칙이 필요한가?
- 훅은 렌더링 순서에 기반하여 상태를 추적합니다.
- 훅의 호출 순서가 매번 같아야 React가 어떤 상태가 어떤 훅에 해당하는지를 정확히 매칭할 수 있습니다.

### ❌ 잘못된 예 (조건문 안에서 훅 사용)
```jsx
function MyComponent() {
  if (someCondition) {
    const [x, setX] = useState(0); // ❌ 훅은 조건문 안에서 호출하면 안 됨
  }
}
```
- someCondition의 값이 변하면서 훅이 호출되거나 안 되면, 순서가 어긋나 상태 관리가 꼬이게 됩니다.
- 이는 매우 치명적인 버그로 이어질 수 있어 React가 강하게 금지합니다.

✅ 올바른 방식 (Top-level에서만 훅 호출)
```jsx
function MyComponent() {
  const [x, setX] = useState(0); // 항상 호출됨
  ...
  if (someCondition) {
    // 훅이 아니라 로직만 분기
  }
}
```

