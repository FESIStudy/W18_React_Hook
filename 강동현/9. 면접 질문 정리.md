# 면접 질문 & 예상 답안 정리
## ✅ 1. useEffect는 언제 실행되며, 어떤 순서로 클린업이 되나요?
핵심 개념:
- useEffect는 렌더링 결과가 DOM에 반영된 뒤, 비동기적으로 실행됨
- 이전 렌더의 clean-up → 다음 effect 실행 순서

예시 답변:
```
useEffect는 컴포넌트 렌더링 이후, 브라우저가 화면을 그린 다음에 실행됩니다.  
이전에 실행된 effect가 있다면 그에 대한 clean-up 함수가 먼저 호출된 후,  
다음 effect가 실행됩니다.  

즉, 렌더링 → 이전 clean-up → 현재 effect 순으로 진행됩니다.

예를 들어 이벤트 리스너나 타이머를 등록할 경우,  
컴포넌트가 업데이트될 때마다 이전 것을 clean-up한 뒤 새롭게 등록됩니다.
```

## ✅ 2. 상태가 stale하게 유지되는 이유는 무엇인가요?
핵심 개념:
- 함수형 컴포넌트는 렌더마다 자신만의 클로저를 갖고 있음
- 이전 렌더에서 생성된 비동기 함수나 타이머는 오래된 클로저 참조 → stale 상태

예시 답변:
```javascript
상태가 stale하게 유지되는 이유는, 함수형 컴포넌트가 렌더링마다 새로운 클로저를 생성하기 때문입니다.  
이전 렌더에서 만든 비동기 함수나 setInterval 내부에서는 최신 state가 아니라  
당시 클로저에 담긴 오래된 state를 참조하게 됩니다.

이를 방지하려면 함수형 업데이트(setState(prev => ...))를 사용하거나  
useRef를 활용해 최신 상태를 유지하는 방법이 있습니다.
```

## ✅ 3. useRef와 useState의 차이는 무엇인가요?
핵심 개념:
|항목|	useState|	useRef|
|-|-|-|
|상태 변경|	변경 시 리렌더링 발생|	변경해도 리렌더링 없음|
|목적|	UI 상태 제어 (보여지는 값)|	내부 값 유지 (렌더링과 무관)|
|주요 활용|	입력값, 토글 등 인터랙션|	DOM 접근, 이전 값 기억, 타이머 ID|

예시 답변:
```
useState는 상태가 바뀌면 컴포넌트를 다시 렌더링하지만,  
useRef는 값을 바꿔도 리렌더링이 일어나지 않습니다.

useState는 UI에 영향을 주는 상태에 쓰고,  
useRef는 DOM 접근이나 이전 값을 저장하거나  
렌더링과 무관한 값을 유지할 때 사용합니다.
```

## ✅ 4. 커스텀 훅을 어떻게 구조화하고 분리하나요?
핵심 개념:
- 단일 책임 원칙(SRP) 기반 분리
- 상태 관련 훅 (useInput, useToggle) vs 동작 관련 훅 (useDebounce, useFetch) 구분
- Composable Hook: 내부에서 다른 훅을 조합

예시 답변:
```
저는 커스텀 훅을 설계할 때 단일 책임 원칙을 기준으로 나눕니다.  
예를 들어 상태 제어만 하는 훅은 useInput처럼 간결하게,  
비동기 처리나 로직이 복잡한 경우는 useFetch처럼 별도로 분리합니다.

또한 내부적으로 여러 훅을 조합하는 Composable Hook 패턴을 통해  
복잡한 기능도 재사용 가능하게 만들고, 테스트도 용이하게 합니다.
```

## ✅ 5. useLayoutEffect는 언제 사용하고, 어떤 경우 주의해야 하나요?
핵심 개념:
- DOM이 변경된 직후, 화면이 그려지기 전에 실행됨
- 레이아웃 계산, 포커스, 스크롤 위치 조정에 적합
- 차단(blocking)이므로 렌더링 성능에 영향 → 꼭 필요한 경우만 사용

예시 답변:
```
useLayoutEffect는 DOM이 변경된 후, 브라우저가 화면을 그리기 전에 동기적으로 실행됩니다.  
따라서 스크롤 위치 조정, 포커스 제어, 레이아웃 측정 등에 적합합니다.

다만 blocking이기 때문에, 화면 깜빡임이나 렌더링 지연을 유발할 수 있어  
비동기 로직이나 API 호출에는 사용을 피하고, 꼭 필요한 상황에만 써야 합니다.
```

## ✅ 6. useCallback과 React.memo는 항상 성능을 높이나요?
핵심 개념:
- 둘 다 불필요한 재렌더링 방지를 위한 도구
- 하지만 메모이제이션 비용이 더 크면 오히려 성능 저하 가능
- 함수나 props가 실제로 자주 바뀌는 경우에만 적용

예시 답변:
```
useCallback과 React.memo는 성능 최적화를 위한 도구지만,  
항상 성능을 높이지는 않습니다. 오히려 지나치게 쓰면  
메모이제이션 자체의 비용이 더 커질 수 있습니다.

이들을 적용하기 전에, props가 자주 바뀌는지,  
자식 컴포넌트가 무겁거나 자주 리렌더링되는지를 먼저 분석하고,  
필요한 경우에만 사용하는 것이 좋습니다.
```

🧠 추가 팁: 구조화된 표현 방식
|질문|	포인트 요약|
|-|-|
|useEffect 실행 시점|	렌더 후, 브라우저 paint 후 실행|
|클로저 stale 문제|	렌더별 클로저 생성 → 이전 상태 참조|
|useRef vs useState|	상태 유지 vs UI 반영|
|커스텀 훅 분리 기준|	단일 책임, 응집도, 재사용성|
|useLayoutEffect 용도|	DOM 변화 직후 레이아웃 계산 등|
|useCallback/memo|	성능 최적화 → 조건부로 사용|

