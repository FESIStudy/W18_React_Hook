## 1. 리액트 훅의 탄생 배경과 철학

### 1-1. 훅은 왜 등장했는가?

* 클래스 컴포넌트는 다음과 같은 **구조적 한계**를 갖고 있었음:

  * 재사용 어려움: 로직 재사용이 `HOC`, `render props`로 복잡
  * this 바인딩: 문법 이해와 오류 방지 비용 증가
  * 긴 컴포넌트 수명 주기: `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`가 단일 로직에 얽힘

-> **함수형 컴포넌트에서 상태와 생명주기를 관리할 수 있게 만든 것이 Hook의 본질적인 목적**

### 1-2. 훅의 철학: **함수형 UI에 상태와 부수효과를 연결하는 인터페이스**

> 훅은 단순한 유틸 함수가 아니라, **React의 렌더링 컨텍스트에 깊이 연결된 상태 머신**

* **useState, useEffect, useRef, useReducer 등**은 내부적으로 렌더링 시스템과 밀접하게 연결되어 있음
* 이 철학은 다음의 **규칙적인 사용 패턴**을 요구함

## 2. 훅의 설계 원칙과 사용 규칙

### 2-1. **훅 사용의 두 가지 규칙**

| 규칙                         | 설명                                                 |
| -------------------------- | -------------------------------------------------- |
| 1. Top-level only          | 훅은 **컴포넌트의 최상위에서만 호출**해야 함. 조건문, 루프, 중첩 함수에서 호출 불가 |
| 2. Only in React Functions | 훅은 **React 함수형 컴포넌트** 또는 **커스텀 훅** 내에서만 호출 가능      |

이 규칙을 어기면 React가 훅의 순서를 보장할 수 없어 동기화 오류 발생 위험 있음.

### 2-2. 예외 케이스

```tsx
// 조건문 안의 useState: 절대 금지
if (someCondition) {
  const [count, setCount] = useState(0); // 훅 인덱스 어긋남
}
```

## 3. 훅의 작동 원리: 내부 메커니즘

### 3-1. 렌더링과 훅 저장 방식

* 리액트는 각 컴포넌트마다 **훅 인덱스를 기반으로 한 훅 목록을 배열 형태로 관리**함
* 예: `const [a] = useState()`, `const [b] = useState()` → 순서대로 인덱스 0, 1에 저장됨

```ts
// 내부 개념도
const hookStates = [state1, state2, ...]; // useState 등 훅 값 저장
let hookIndex = 0;
```

* 렌더링 시마다 hookIndex는 0부터 시작하며, **훅을 호출할 때마다 순차적으로 hookStates에 접근**

➡️ 순서 기반 매핑이기 때문에 **조건문 안에서 훅을 호출하면 순서가 바뀌어 동작이 깨짐**

---

### 3-2. useState의 내부 구현 개요

```ts
// 간단화된 의사 코드
function useState(initialValue) {
  const currentIndex = hookIndex;
  if (!hookStates[currentIndex]) {
    hookStates[currentIndex] = initialValue;
  }

  const setState = (newValue) => {
    hookStates[currentIndex] = newValue;
    render(); // 컴포넌트 리렌더 트리거
  }

  hookIndex++;
  return [hookStates[currentIndex], setState];
}
```

* `hookStates`는 **컴포넌트 단위로 유지되는 배열**
* `hookIndex`는 렌더링 중 전역적으로 증가되며 각 훅을 유일하게 구분

---

### 3-3. 클로저와 훅의 연결 구조

* 훅 내부에서 반환하는 `setState`는 **렌더링 시점의 상태를 기억하는 클로저** 형태
* 이 클로저가 `React`의 렌더링 컨텍스트와 이어져 있기 때문에 외부 변수처럼 보이더라도 별도로 감지됨

---

## 면접 질문 대비 포인트

### Q1. "왜 useState는 조건문 안에서 쓰면 안 되나요?"

**답변 예시 (4줄 서술형)**
useState 등 훅은 호출 순서에 따라 React가 내부 상태 배열과 연결합니다. 조건문 안에서 훅을 호출하면 렌더링마다 훅의 순서가 달라져 오류가 발생합니다. React는 hookIndex라는 인덱스를 통해 상태를 식별하기 때문에, 순서를 유지하는 것이 핵심입니다. 따라서 훅은 항상 컴포넌트의 최상단에서만 호출되어야 합니다.

**추가 설명**

* 이 규칙을 지키지 않으면 "Rendered more hooks than during the previous render" 오류 발생 가능
* React DevTools에서도 훅 순서가 어긋나면 추적 불가능

## 정리 요약

| 항목    | 내용                                        |
| ----- | ----------------------------------------- |
| 훅의 목적 | 클래스 컴포넌트의 복잡성과 재사용성 한계를 해결                |
| 철학    | 상태와 부수효과를 함수형 UI에 연결하는 인터페이스              |
| 핵심 원리 | 훅은 렌더링 컨텍스트에 연결된 순차적 상태 저장 시스템            |
| 내부 구조 | 훅 배열 (hookStates) + 훅 인덱스 (hookIndex)로 동작 |
| 주의점   | 훅은 항상 같은 순서로 호출되어야 함 (조건문 사용 금지)          |
